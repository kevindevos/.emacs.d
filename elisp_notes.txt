;; emacs manual with info
;; press 'T' goes into info table of contents (info-toc)

;; define a group for customization, for M-x customize-groups things
(defgroup company nil
  "Extensible inline text completion mechanism"
  :group 'abbrev
  :group 'convenience
  :group 'matching)

;; defcustom , declares company-frontends as a customizable variable
;; (defcustom SYMBOL STANDARD DOC &rest ARGS)
(defcustom company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
                               company-preview-if-just-one-frontend
                               company-echo-metadata-frontend)


;; faces
;; a collection of graphical atributes , check info

;;company-frontends
;;A company frontend is a visualization, there can exist multiple, each frontend
;; is a function that takes one argument that can be:

;; ‘show’: When the visualization should start.

;; ‘hide’: When the visualization should end.

;; ‘update’: When the data has been updated.

;; ‘pre-command’: Before every command that is executed while the
;; visualization is active.

;; ‘post-command’: After every command that is executed while the
;; visualization is active.


;; DOLIST loop (like a short foreach)
;; dolist is a Lisp macro in ‘subr.el’.
;; (dolist (VAR LIST [RESULT]) BODY...)


;; (pcase EXP &rest CASES)
;; Evaluate EXP and attempt to match it against structural patterns.
;; CASES is a list of elements of the form (PATTERN CODE...).

;; (defun recip (n)
;;   (pcase n
;;     (`0 (error "Can't divide by zero"))
;;     (n (/ 1.0 n))))

;; (recip 0)
;; ==> (error "Can't divide by zero")
;; (recip 2)
;; ==> 0.5

;;(pcase-dolist (PATTERN LIST) BODY...)
;;Like ‘dolist’ but where the binding can be a ‘pcase’ pattern.

;; when 
;; (when COND BODY...)

;; if  
;; (if COND THEN ELSE...)

;; (unless COND BODY...)

;; If COND yields nil, do BODY, else return nil.
;; When COND yields nil, eval BODY forms sequentially and return
;; value of last one, or nil if there are none.


;; absval


;; back quote
;; quotes a list but selectively evaluates elements in that list

     ;; `(a list of (+ 2 3) elements)
     ;;      ⇒ (a list of (+ 2 3) elements)
     ;; '(a list of (+ 2 3) elements)
     ;;      ⇒ (a list of (+ 2 3) elements)

;; cons
;;(cons CAR CDR)

;;Create a new cons, give it CAR and CDR as components, and return it.

;; cl-case
;; (cl-case EXPR (KEYLIST BODY...)...)

;; Eval EXPR and choose among clauses on that value.
;; Each clause looks like (KEYLIST BODY...).  EXPR is evaluated and
;; compared against each key in each KEYLIST; the corresponding BODY
;; is evaluated.  If no clause succeeds, cl-case returns nil.  
          ;; (cl-case (read-char)
          ;;   (?a (do-a-thing))
          ;;   (?b (do-b-thing))
          ;;   ((?\r ?\n) (do-ret-thing))
          ;;   (t (do-other-thing)))

